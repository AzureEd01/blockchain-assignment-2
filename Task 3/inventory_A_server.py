import hashlib

inventoryA_id = 126
randomA = 621
tA = ''
sA = ''
node_name = 'A'

#sends the id/ public key 
def inv_A_key_req():
    return inventoryA_id 

def calc_tA():
    from pkg_server import get_pkg_e
    from pkg_server import get_pkg_n
    pkg_e = get_pkg_e()
    pkg_n = get_pkg_n()
    tA = pow(randomA, pkg_e, pkg_n)
    return tA

def a_calc_aggregated_t(tA, tB, tC, tD):
    from pkg_server import get_pkg_n
    pkg_n = get_pkg_n()
    t = (tA * tB) % pkg_n
    t = (t * tC) % pkg_n
    t = (t * tD) % pkg_n
    return t

def a_calc_partial_sig(m, t, gJ):
    randomJ = randomA
    from pkg_server import get_pkg_n
    pkg_n = get_pkg_n()
    m = str(t) + m
    hash_m = hashlib.md5(m.encode()).hexdigest()
    decimal_m = int(hash_m, 16)
    rJ_exp = pow(randomJ, decimal_m, pkg_n)
    sJ = (gJ * rJ_exp) % pkg_n
    return sJ

def a_calc_multisig(sA, sB, sC, sD):
    from pkg_server import get_pkg_n
    pkg_n = get_pkg_n()
    s = (sA * sB) % pkg_n
    s = (s * sC) % pkg_n
    s = (s * sD) % pkg_n
    return s 

def get_privkey_A():
    from pkg_server import get_priv_key
    gA = get_priv_key('A')
    return gA

#-------------------------------------------
#searches the database (txt file) for the given input 
def inventory_A_search(record_id):
    global sA
    with open('A_inventory_db.txt') as f:
        lines = f.readlines()
        for row in lines:
            if record_id in row:
                print(row.split(','))
                split_row = row.split(',')
                qty = split_row[1].strip()
                return qty
    return None

# PBFT proposer function to create proposal
            
#Calculate tA for aggregated t 
def calc_tA():
    from pkg_server import get_pkg_e
    from pkg_server import get_pkg_n
    #Get the pkg e (part of public key)
    pkg_e = get_pkg_e()
    pkg_n = get_pkg_n()
    tA = pow(randomA, pkg_e, pkg_n)
    return tA

#calculates aggregated t using the others inventorys' ts
def a_calc_aggregated_t(tA, tB, tC, tD):
    from pkg_server import get_pkg_n
    pkg_n = get_pkg_n()
    t = (tA * tB * tC * tD) % int(pkg_n)
    return t

#sends the public key (inventory id) 
def inv_A_key_req():
    return inventoryA_id 

#sends the private key (generated by the PKG)
def get_privkey_A():
    from pkg_server import get_priv_key
    gA = get_priv_key('A')
    return gA

#calculates partial signature
def a_calc_partial_sig(m, t, gJ):
    #get random number 
    randomJ = randomA
    #get pkg n
    from pkg_server import get_pkg_n
    pkg_n = get_pkg_n()
    #append message to t
    m = str(t) + m
    #hash message
    hash_m = hashlib.md5(m.encode()).hexdigest()
    #convert message to int 
    decimal_m = int(hash_m, 16)
    #Each signer also computes sj = gj*rj^H(t,m) mod n , this is then shared with eachother
    rJ_exp = pow(randomJ, decimal_m, pkg_n)
    sJ = (gJ * rJ_exp) % pkg_n
    return sJ

#Calculates the multi signature using the other inventorys' partial signatures
def a_calc_multisig(sA, sB, sC, sD):
    #get pkg n
    from pkg_server import get_pkg_n
    pkg_n = get_pkg_n()
    #calc
    s = (sA * sB * sC * sD) % pkg_n
    return s 

# Consensus
def pbft_propose(record_id):
    from inventory_B_server import calc_tB, b_calc_partial_sig
    from inventory_C_server import calc_tC, c_calc_partial_sig
    from inventory_D_server import calc_tD, d_calc_partial_sig

    # Step 1: Local search for quantity
    qty_A = inventory_A_search(record_id)
    if qty_A is None:
        print("Record not found in A's inventory.")
        return None

    # Step 2: Calculate t-values
    tA = calc_tA()
    tB = calc_tB()
    tC = calc_tC()
    tD = calc_tD()

    # Step 3: Aggregate t
    agg_t = a_calc_aggregated_t(tA, tB, tC, tD)

    # Step 4: Get private keys
    gA = get_privkey_A()
    from inventory_B_server import get_privkey_B
    gB = get_privkey_B()
    from inventory_C_server import get_privkey_C
    gC = get_privkey_C()
    from inventory_D_server import get_privkey_D
    gD = get_privkey_D()

    # Step 5: Calculate partial signatures
    sA = a_calc_partial_sig(qty_A, agg_t, gA)
    sB = b_calc_partial_sig(qty_A, agg_t, gB)
    sC = c_calc_partial_sig(qty_A, agg_t, gC)
    sD = d_calc_partial_sig(qty_A, agg_t, gD)

    # Step 6: Build proposal dictionary with all partial signatures and t values
    proposal = {
    'qty': qty_A,
    'agg_t': agg_t,
    'sA': sA,
    'sB': sB,
    'sC': sC,
    'sD': sD,
    'tA': tA,
    'tB': tB,
    'tC': tC,
    'tD': tD
    }


    # Step 7: PBFT voting from replicas (B, C, D)
    from inventory_B_server import pbft_vote_on_primary as vote_B
    from inventory_C_server import pbft_vote_on_primary as vote_C
    from inventory_D_server import pbft_vote_on_primary as vote_D

    vote_result_B = vote_B(proposal)
    vote_result_C = vote_C(proposal)
    vote_result_D = vote_D(proposal)


    votes = [vote_result_B, vote_result_C, vote_result_D]

    print("Votes from replicas:", votes)

    # Step 8: Check consensus (at least 2 out of 3 must agree)
    if votes.count(True) >= 2:
        print("✔ PBFT consensus reached.")
        return proposal
    else:
        print("✘ PBFT consensus failed.")
        return None
