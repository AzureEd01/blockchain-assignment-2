<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Inventory PoW Simulation</title>
  <style>
    body {
      font-family: sans-serif;
      max-width: 800px;
      margin: auto;
      padding: 2em;
    }
    input, button {
      padding: 0.5em;
      margin: 0.5em 0;
      width: 100%;
    }
    pre {
      background: #f4f4f4;
      padding: 1em;
      overflow-x: auto;
    }
  </style>
</head>
<body>
  <h1>Inventory Record with Proof of Work</h1>

  <form id="inventory-form">
    <label>ItemID: <input type="text" id="itemID" required></label><br>
    <label>Item Quantity: <input type="number" id="itemQTY" required></label><br>
    <label>Item Price: <input type="number" id="itemPrice" required></label><br>
    <label>Location: <input type="text" id="location" required></label><br>
    <label>Leading Zeros (Difficulty): <input type="number" id="difficulty" value="4"></label><br>
    <button type="submit">Submit and Mine</button>
  </form>

  <h2>Result</h2>
  <pre id="output">Waiting for input...</pre>

  <script>
    const output = document.getElementById('output');

    // Simple inventory across 4 "nodes"
    const inventories = {
      Node1: [],
      Node2: [],
      Node3: [],
      Node4: []
    };

    // Convert record to string
    function recordToString(record) {
      return `${record.ItemID}-${record.ItemQTY}-${record.ItemPrice}-${record.Location}`;
    }

    // SHA-256 hashing using SubtleCrypto
    async function sha256(text) {
      const encoder = new TextEncoder();
      const data = encoder.encode(text);
      const hashBuffer = await crypto.subtle.digest('SHA-256', data);
      return Array.from(new Uint8Array(hashBuffer)).map(b => b.toString(16).padStart(2, '0')).join('');
    }

    // Proof of Work function
    async function mine(recordString, difficulty) {
      const prefix = '0'.repeat(difficulty);
      let nonce = 0;
      let hash;

      const startTime = performance.now();
      while (true) {
        const text = recordString + nonce;
        hash = await sha256(text);
        if (hash.startsWith(prefix)) {
          const elapsed = ((performance.now() - startTime) / 1000).toFixed(2);
          return { nonce, hash, elapsed };
        }
        nonce++;
      }
    }

    // Validation function
    function isValid(record) {
      return Object.values(inventories).every(inv =>
        !inv.some(existing => existing.ItemID === record.ItemID)
      );
    }

    // Form handling
    document.getElementById('inventory-form').addEventListener('submit', async (e) => {
      e.preventDefault();
      output.textContent = '‚õèÔ∏è Mining in progress...';

      const record = {
        ItemID: document.getElementById('itemID').value,
        ItemQTY: parseInt(document.getElementById('itemQTY').value),
        ItemPrice: parseInt(document.getElementById('itemPrice').value),
        Location: document.getElementById('location').value.toUpperCase()
      };
      const difficulty = parseInt(document.getElementById('difficulty').value);
      const recordString = recordToString(record);

      // Simulate miner selection
      const miner = 'Node' + (Math.floor(Math.random() * 4) + 1);

      const { nonce, hash, elapsed } = await mine(recordString, difficulty);

      if (isValid(record)) {
        for (const node in inventories) {
          inventories[node].push(record);
        }
        output.textContent =
          `‚úÖ Record accepted by all nodes.\n` +
          `Miner: ${miner}\nNonce: ${nonce}\nHash: ${hash}\nTime: ${elapsed}s\n\n` +
          `üì¶ Final Inventories:\n` +
          Object.entries(inventories).map(([node, inv]) =>
            `${node}: ${inv.map(i => i.ItemID).join(', ')}`
          ).join('\n');
      } else {
        output.textContent =
          `‚ùå Record rejected (duplicate ItemID).\n` +
          `Miner: ${miner}\nNonce: ${nonce}\nHash: ${hash}\nTime: ${elapsed}s`;
      }
    });
  </script>
</body>
</html>
